#!/usr/bin/env bash

# Default values
START_PATH="."
MIN_SIZE_MB=500
MAX_DEPTH=4
INCLUDE_HIDDEN=false
TREE_FORMAT=false
VERSION="1.0.0"

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -p|--path)
            START_PATH="$2"
            shift 2
            ;;
        -s|--size)
            MIN_SIZE_MB="$2"
            shift 2
            ;;
        --include-hidden)
            INCLUDE_HIDDEN=true
            shift
            ;;
        -t|--tree)
            TREE_FORMAT=true
            shift
            ;;
        -h|--help)
            echo "Usage: $0 [-p path] [-s size_mb] [--include-hidden] [-t]"
            echo ""
            echo "Options:"
            echo "  -p, --path PATH     Starting path (default: current directory '.')"
            echo "  -s, --size SIZE     Minimum size in MB (default: 500)"
            echo "  --include-hidden    Include hidden files and folders"
            echo "  -t, --tree          Display in tree format (default: simple list)"
            echo "  -h, --help          Show this help message"
            echo ""
            echo "Examples:"
            echo "  $0 -p /home/user -s 100"
            echo "  $0 -s 50 -t"
            echo "  $0 -p . -s 200 --include-hidden -t"
            exit 0
            ;;
        -v|--version)
            echo "ddysk version $VERSION"
            exit 0
            ;;
        *)
            echo "Unknown option: $1"
            echo "Use -h or --help for usage information"
            exit 1
            ;;
    esac
done

MIN_SIZE_KB=$((MIN_SIZE_MB * 1024))

# Convert to absolute path if current directory
if [ "$START_PATH" = "." ]; then
    START_PATH="$(pwd)"
fi

if [ ! -d "$START_PATH" ]; then
    echo "‚ùå Path '$START_PATH' does not exist."
    exit 1
fi

if [ "$TREE_FORMAT" = true ]; then
    echo "üìÇ Folders & Files ‚â• $MIN_SIZE_MB MB under '$START_PATH' (depth ‚â§ $MAX_DEPTH):"
else
    echo "Folders & Files ‚â• $MIN_SIZE_MB MB under '$START_PATH':"
fi
echo ""

# Collect folders with their total sizes
if [ "$INCLUDE_HIDDEN" = true ]; then
    find "$START_PATH" -maxdepth "$MAX_DEPTH" -type d | while read -r dir; do
        SIZE_KB=$(du -sk "$dir" 2>/dev/null | awk '{print $1}')
        if [ "$SIZE_KB" -ge "$MIN_SIZE_KB" ]; then
            echo "d|$dir|$SIZE_KB"
        fi
    done > /tmp/folder_sizes_$$
else
    find "$START_PATH" -maxdepth "$MAX_DEPTH" -type d ! -path "*/.*" | while read -r dir; do
        SIZE_KB=$(du -sk --exclude=".*" "$dir" 2>/dev/null | awk '{print $1}')
        if [ "$SIZE_KB" -ge "$MIN_SIZE_KB" ]; then
            echo "d|$dir|$SIZE_KB"
        fi
    done > /tmp/folder_sizes_$$
fi

# Collect large files
if [ "$INCLUDE_HIDDEN" = true ]; then
    find "$START_PATH" -maxdepth "$MAX_DEPTH" -type f -size "+${MIN_SIZE_MB}M" 2>/dev/null | while read -r file; do
        SIZE_KB=$(du -sk "$file" 2>/dev/null | awk '{print $1}')
        echo "f|$file|$SIZE_KB"
    done >> /tmp/folder_sizes_$$
else
    find "$START_PATH" -maxdepth "$MAX_DEPTH" -type f ! -path "*/.*" -size "+${MIN_SIZE_MB}M" 2>/dev/null | while read -r file; do
        SIZE_KB=$(du -sk "$file" 2>/dev/null | awk '{print $1}')
        echo "f|$file|$SIZE_KB"
    done >> /tmp/folder_sizes_$$
fi

# Sort by path
sort -t'|' -k2 /tmp/folder_sizes_$$ > /tmp/sorted_$$

# Function to get color based on size
get_size_color() {
    local size_mb=$1
    if [ "$size_mb" -lt 1000 ]; then
        echo "\e[32m"  # Green for < 1GB
    elif [ "$size_mb" -lt 5000 ]; then
        echo "\e[33m"  # Yellow for 1GB - 5GB
    elif [ "$size_mb" -lt 10000 ]; then
        echo "\e[35m"  # Magenta for 5GB - 10GB
    else
        echo "\e[31m"  # Red for > 10GB
    fi
}

# Read and display
if [ "$TREE_FORMAT" = true ]; then
    # Tree format display
    while IFS='|' read -r type path size_kb; do
        size_mb=$((size_kb/1024))
        
        # Calculate depth relative to START_PATH
        relative_path="${path#$START_PATH}"
        relative_path="${relative_path#/}"
        
        if [ -z "$relative_path" ]; then
            # Root folder
            color=$(get_size_color "$size_mb")
            echo -e "\e[32müìÅ $(basename "$path")\e[0m - ${color}${size_mb} MB\e[0m"
        else
            # Count depth by number of slashes
            depth=$(echo "$relative_path" | tr -cd '/' | wc -c)
            
            # Create indentation
            indent=""
            for ((i=0; i<depth; i++)); do
                indent="${indent}‚îÇ   "
            done
            
            # Use appropriate icon
            if [ "$type" = "d" ]; then
                icon="üìÅ"
                icon_color="\e[32m"
            else
                icon="üìÑ"
                icon_color="\e[34m"
            fi
            
            # Get size color
            color=$(get_size_color "$size_mb")
            
            # Use tree characters
            echo -e "${indent}‚îú‚îÄ‚îÄ ${icon_color}${icon}\e[0m $(basename "$path") - ${color}${size_mb} MB\e[0m"
        fi
    done < /tmp/sorted_$$
else
    # Simple list format: path - size
    while IFS='|' read -r type path size_kb; do
        size_mb=$((size_kb/1024))
        color=$(get_size_color "$size_mb")
        if [ "$type" = "d" ]; then
            icon_color="\e[32m"
            icon="üìÅ"
        else
            icon_color="\e[34m"
            icon="üìÑ"
        fi
        echo -e "${icon_color}${icon}\e[0m $path - ${color}${size_mb}MB\e[0m"
    done < /tmp/sorted_$$
fi

# Cleanup
rm -f /tmp/folder_sizes_$$ /tmp/sorted_$$